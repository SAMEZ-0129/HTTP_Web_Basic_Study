# HTTP 헤더 
## HTTP 헤더 개요
헤더는 field-name":" OWS field-value OWS 형식으로 이루어져 있음
헤더의 용도
- HTTP 전송에 필요한 모든 부가정보: 메시지 바디의 내용, 메시지 바디 크기, 압축, 인증, 요청 클라이언트...등
- 표준 헤더는 엄청 많기에 필요 시 직접 찾아보길
- 필요 시 임시의 헤더 추가 가능하다 (helloworld:hihi)

과거 스펙:![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/48321461-4edd-412f-8c6e-c89356f53d80)
이후 스펙의 변경: 엔티티 -> 표현(representation)

최신 스펙:![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/40c9be43-b2a2-410f-812c-96408ba44016)
표현이라는 말로 변경된 이유: 실제 전달할 데이터들이 어떻게 **표현**될 것인지에 대한 정의

## 표현(Representation)
Content-Type: 표현 데이터의 형식-미디어 타입, 문자 인코딩, 전송될 데이터의 형식
Content-Encoding: 표현 데이터의 압축 방식-표현 데이터를 압축하기 위해 주로 사용, 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가(받는 쪽에서 인코딩 된 데이터를 풀 수 있기 위해)
Content-Language: 표현 데이터의 자연 언어(ko,en,jp...등), 예시로 애플 홈페이지를 갔을 때 영어 사이트로 들어갔는데 한국어로 바꿀지 물어보는 팝업 나타남
Content-Length: 표현 데이터의 길이(바이트 단위) *Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨
표현 헤더는 전송, 응답 둘다 사용한다

## 협상(Content Negotiation): 클라이언트가 선호하는 표현 요청(클라이언트가 원하는 형식으로 요청하는 것)
- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 자연 언어
예로 들어 클라이언트(한국)-서버(미국 웹사이트)끼리 통신을 한다고 가정해보자
서버는 한국어를 지원하지만 기본 디폴트 값은 영어로 제공하고 있다
클라이언트가 요청을 했을 때 Accept-Language가 적용되어 있지 않다면 그냥 기본 값인 영어로 응답이 온다
Accept-Language가 적용되어 있다면, 클라이언트가 요청을 했을 때(GET /event ... Accept-Language:ko) 서버는 해당 언어(를 지원한다면)로 응답을 보내준다

협상과 우선순위 1(Quality Values)
![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/183baef4-f4b3-48d8-bc62-94a001a0c71b)
Quality Values 값을 통해 선호 값에 우선순위를 지정할 수 있다
0~1 사이의 값을 가지며, 클 수록 높은 우선순위를 가진다(예시: ko=0.9,en=0.6,jp=0.5 > 한국어로 보여주고 지원하지 않으면 영어, 지원하지 않으면 일본어로)

협상과 우선순위 2
구체적인 것이 우선한다
![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/2da65f34-d681-42a9-ad74-35994daeba9d)
위 예시의 우선순위는 다음과 같다 ![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/3a833345-c028-4ca2-9e1a-684bc6d51ea8)

협상과 우선순위 3
구체적인 것을 기준으로 미디어 타입을 맞춘다
![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/02f1e79c-c95d-44c6-a4c0-61da47138f6a)

## 전송 방식
단순 전송: content-length 구체적인 요청 값을 알고 있을 때 요청을 전송하면 해당 응답을 받음

압축 전송: content-encoding을 통해 압축된 요청을 전송한다

분할 전송: transfer-encoding을 통해 너무 긴 요청 값을 분할해서 전송함. 요청이 너무 길어서 처리하는데 시간이 오래 걸릴 경우 분할해서 전송하면 미리 받아보면서 처리가 가능(content-length를 넣으면 안됨!)

범위 전송: Range, Content-length 예로들어 중간에 응답받다가 연결이 끊킬 경우 처음부터 다시 받기 아까우니 범위 전송을 통해 특정 부분부터 데이터를 요청할 수 있음

## 일반 정보
From: 유저 에이전트의 이메일 정보(일반적으로 잘 사용되지 않음, 검색 엔진 같은 곳에서 사용

Referer: 이전 웹 페이지 주소
현재 요청된 페이지의 이전 페이지 주소
유입 경로 분석 가능
A -> B로 이동하는 경우 B를 요청할 때 Referer:A를 포함해서 요청

User-Agent: 유저 에이전트 애플리케이션 정보
클라이언트의 애플리케이션 정보(웹 브라우저 정보, 등등)
통계 정보에서 사용, 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능, 요청에서 사용함

Server: 요청을 처리하는 Origin 서버의 소프트웨어 정보
ex) Server:Apache/2.2.22(Debian)
중간에 거치는 서버들 말고 진짜로 마지막에 요청이 발생하는 서버를 표시

Date: 메시지가 발생한 날짜와 시간
응답에서만 사용함

## 특별한 정보
Host: 요청한 호스트 정보(도메인)
요청에서 사용함
**필수 값이다!**
하나의 서버가 여러 도메인을 처리해야 할 때 사용한다
하나의 IP 주소에 여러 도메인이 적용되어 있을 때 구분을 위해 사용
예로들어, 서버에는 하나의 애플리케이션만 처리하는 것이 아닌 여러 애플리케이션에 대한 처리를 진행하는데
클라이언트에서 요청을 보냈을 때 해당 처리는 서버에서 어느 애플리케이션 요청인지 확인하기 위해 사용

Location: 페이지 리다이렉션 위치
![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/1618eaa8-653e-47e4-9895-043f8d8906a9)

Allow: 허용 가능한 HTTP 메서드
서버에서 지원하는 메서드에 대한 정보를 전달함

Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
서버 점검 같은 이슈가 있을 때 복구 예상 시간 같은 정보 전달

## 인증
Authorization: 클라이언트 인증 정보를 서버에 전달할 수 있다
인증 관련된 값은 인증 방법에 따라 헤더에 들어가는 값이 다르기에 관련 공부를 통해 확인 가능

WWW-Authenticate: 리소스 접근 시 필요한 인증 방법 정의
리소스 접근 시 필요한 인증 방법에 대한 정의, 401 Unauthorized 응답과 함께 사용해서 인증 관련해서 어떤 정보가 필요한지 전달

## 쿠키
쿠키를 사용하지 않을 경우: 유저가 hello 페이지 접근(안녕하세요,손님) -> 유저가 로그인(홍길동님으로 로그인되었습니다) -> 로그인 후 hello페이지 접근(안녕하세요**손님**) 
웹 페이지는 요청을 보내는 대상이 홍길동으로 로그인한 사용자인지 알 수 없음
HTTP는 기본적으로 무상태(stateless) 프로토콜이다
클라이언트와 서버가 응답을 주고 받으면 연결은 끊어진다(실제로 완전 끊키는 것은 아님) -> 서버는 이전 요청을 기억하지 않음 -> 클라이언트와 서버는 서로 상태를 유지하지 않음
=> 상태를 유지하지 않기 때문에 발생하는 것(해결하기 위해서는 유저 정보를 매 요청마다 포함해서 보내면 되긴함 = 보안 이슈,리소스 낭비, 브라우저 종료 후 다시 열면?)

쿠키를 사용할 경우: 사용자 로그인 -> 서버에서 유저 정보를 쿠키 헤더로 담아서 응답을 클라이언트로 반환 -> 클라이언트는 받은 쿠키 데이터를 브라우저 내부 쿠키 저장소에 저장함 -> 사용자가 로그인 후 페이지 접근 시 생성된 쿠키를 요청 헤더에 추가해서 전달 
실제로 로그인 데이터를 쿠키로 저장해서 서버로 요청할 때 마다 보내진 않음(보안문제), 로그인 성공 시 서버에서 세션 키 같은 것을 만들어서 해당 정보를 통해 클라이언트는 요청할 때 전달(실제 데이터X 세션ID O)
![image](https://github.com/SAMEZ-0129/HTTP_Web_Basic_Study/assets/81644075/428592f9-836e-44b5-b5a3-32217b4f64d5)

쿠키의 생명주기: Expires(만료일이 되면 쿠키 삭제), max-age(초단위 세팅, 0이나 음수를 지정하면 쿠키 삭제), 세션 쿠키(만료 일자를 생략하면 브라우저 종료 시 까지만 유지), 영속 쿠키(만료 일자를 입력하면 해당 날짜까지 유지)

쿠키의 도메인: 쿠키를 사용할 도메일을 지정할 수 있음

쿠키의 경로: 특정 경로를 포함한 하위 경로 페이지만 쿠키 접근

쿠키의 보안
Secure: https인 경우에만 전송
HttpOnly: XSS 공격 방지, 자바스크립트에서 접근 불가, HTTP 전송에만 사용
SameSite: XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

